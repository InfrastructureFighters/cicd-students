## GitLab CI/CD `artifacts` keyword
In GitLab terminology, any files that are generated by a job and then preserved are called `job artifacts`. It’s important to understand that any files that were generated by a job but not declared to be `artifacts` are deleted as soon as the job finishes.
### Where to Find `Artifacts`?
You can download or view job outputs later through the GitLab UI, In the:

 **GitLab web UI** under **CI/CD** > **Jobs** → select a job → see the “Download Artifacts” button.
### Artifact Syntax in **.gitlab-ci.yml**
To create job artifacts, use the `artifacts` keyword in your **.gitlab-ci.yml** file like this:

```yaml
job-name:
  script:
    - <commands>
  artifacts:
    paths:
      - <path/to/file/or/directory>
    expire_in: <time>
    when: <on_success | on_failure | always>
    reports:
      <type>: <path/to/report>
    expose_as: <name>
    name: <custom-filename>
    access: <all | developer>
```
 ### Explanation of Keywords

| Key         | Description                                                        |
| ----------- | ------------------------------------------------------------------ |
| `paths`     | Files/directoris to save as artifacts (e.g. `dist/`, `build.log`)     |
| `expire_in` | How long to keep the artifact (e.g. `1 hour`, `3 days`, `1 week`)  |
| `when`      | When to upload: `on_success` (default), `on_failure`, `always`     |
| `reports`   | Structured output GitLab can parse (e.g. test or coverage reports) |
| `expose_as` | Label to show in GitLab UI (e.g. “Download Report”)                |
| `name`      | Custom name of the artifact archive ZIP file                       |
| `access`    | Who can download it (`all` or `developer`)                         |




### Example
Here’s a basic example illustrating artifact usage:
```yaml
unit-tests:
  stage: test
  image: python:3.10
  script:
    - pip install pytest
    - pytest test/
  artifacts:
    reports:
      junit: unit_test_results.xml
    when: always
```
What the example means:   
This job definition specifies that the job belongs to the test stage, and that it must run within a
Docker container that has version 3.10 of Python installed. The commands that it runs first install
the pytest package using the pip package manager, and then call the newly installed pytest
command to run all unit tests that are in the test/ directory.
This code tells GitLab to preserve the unit_test_results.xml file produced by the pytest
framework. It also designates this file as a report that contains test results that are stored in the JUnit
format, which is an industry-standard format that GitLab knows how to ingest and display. Finally, it
tells GitLab to hold on to this file regardless of whether any of the tests fail. This last step is important
because a failing test will cause the whole unit-tests job to have a failed status, which would
normally cause the artifact to be discarded. But we want to see the results even if any of the tests fail.











































